package simpledb.jdbc;

import java.sql._;
import java.util._;
import java.util.concurrent._;

/** This class implements all of the methods of the Connection interface, by
  * throwing an exception for each one. Subclasses (such as SimpleConnection)
  * can override those methods that it want to implement.
  * @author
  *   Edward Sciore
  */
abstract class ConnectionAdapter extends Connection {
  def clearWarnings() = {
    throw new SQLException("operation not implemented");
  }

  def close() = {
    throw new SQLException("operation not implemented");
  }

  def commit() = {
    throw new SQLException("operation not implemented");
  }

  def createArrayOf(typeName: String, elements: scala.Array[Object]) = {
    throw new SQLException("operation not implemented");
  }

  def createBlob() = {
    throw new SQLException("operation not implemented");
  }

  def createClob() = {
    throw new SQLException("operation not implemented");
  }

  def createNClob() = {
    throw new SQLException("operation not implemented");
  }

  def createSQLXML() = {
    throw new SQLException("operation not implemented");
  }

  def createStatement() = {
    throw new SQLException("operation not implemented");
  }

  def createStatement(resultSetType: Int, resultSetConcurrency: Int) = {
    throw new SQLException("operation not implemented");
  }

  def createStatement(
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ) = {
    throw new SQLException("operation not implemented");
  }

  def createStruct(typeName: String, attributes: scala.Array[Object]) = {
    throw new SQLException("operation not implemented");
  }

  def getAutoCommit() = {
    throw new SQLException("operation not implemented");
  }

  def getCatalog() = {
    throw new SQLException("operation not implemented");
  }

  def getClientInfo() = {
    throw new SQLException("operation not implemented");
  }

  def getClientInfo(name: String) = {
    throw new SQLException("operation not implemented");
  }

  def getHoldability() = {
    throw new SQLException("operation not implemented");
  }

  def getMetaData() = {
    throw new SQLException("operation not implemented");
  }

  def getTransactionIsolation() = {
    throw new SQLException("operation not implemented");
  }

  def getTypeMap() = {
    throw new SQLException("operation not implemented");
  }

  def getWarnings() = {
    throw new SQLException("operation not implemented");
  }

  def isClosed() = {
    throw new SQLException("operation not implemented");
  }

  def isReadOnly() = {
    throw new SQLException("operation not implemented");
  }

  def isValid(timeout: Int) = {
    throw new SQLException("operation not implemented");
  }

  def nativeSQL(sql: String) = {
    throw new SQLException("operation not implemented");
  }

  def prepareCall(sql: String) = {
    throw new SQLException("operation not implemented");
  }

  def prepareCall(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int
  ) = {
    throw new SQLException("operation not implemented");
  }

  def prepareCall(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ) = {
    throw new SQLException("operation not implemented");
  }

  def prepareStatement(sql: String) = {
    throw new SQLException("operation not implemented");
  }

  def prepareStatement(sql: String, autoGeneratedKeys: Int) = {
    throw new SQLException("operation not implemented");
  }

  def prepareStatement(sql: String, columnIndexes: scala.Array[Int]) = {
    throw new SQLException("operation not implemented");
  }

  def prepareStatement(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int
  ) = {
    throw new SQLException("operation not implemented");
  }

  def prepareStatement(
      sql: String,
      resultSetType: Int,
      resultSetConcurrency: Int,
      resultSetHoldability: Int
  ) = {
    throw new SQLException("operation not implemented");
  }

  def prepareStatement(sql: String, columnNames: scala.Array[String]) = {
    throw new SQLException("operation not implemented");
  }

  def releaseSavepoint(savepoin: Savepoint) = {
    throw new SQLException("operation not implemented");
  }

  def rollback() = {
    throw new SQLException("operation not implemented");
  }

  def rollback(svepoint: Savepoint) = {
    throw new SQLException("operation not implemented");
  }

  def setAutoCommit(autoCommit: Boolean) = {
    throw new SQLException("operation not implemented");
  }

  def setCatalog(catalog: String) = {
    throw new SQLException("operation not implemented");
  }

  def setClientInfo(name: String, value: String) {}

  def setClientInfo(properties: Properties) {}

  def setHoldability(holdability: Int) = {
    throw new SQLException("operation not implemented");
  }

  def setReadOnly(readOnly: Boolean) = {
    throw new SQLException("operation not implemented");
  }

  def setSavepoint() = {
    throw new SQLException("operation not implemented");
  }

  def setSavepoint(name: String) = {
    throw new SQLException("operation not implemented");
  }

  def setTransactionIsolation(level: Int) = {
    throw new SQLException("operation not implemented");
  }

  def setTypeMap(map: Map[String, Class[Any]]) = {
    throw new SQLException("operation not implemented");
  }

  def isWrapperFor(iface: Class[Any]) = {
    throw new SQLException("operation not implemented");
  }

  def unwrap(iface: Class[Any]) = {
    throw new SQLException("operation not implemented");
  }

  def abort(executor: Executor) = {
    throw new SQLException("operation not implemented");
  }

  def getNetworkTimeout() = {
    throw new SQLException("operation not implemented");
  }

  def getSchema() = {
    throw new SQLException("operation not implemented");
  }

  def setNetworkTimeout(executor: Executor, milliseconds: Int) = {
    throw new SQLException("operation not implemented");
  }

  def setSchema(schema: String) = {
    throw new SQLException("operation not implemented");
  }
}
